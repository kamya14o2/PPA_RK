---
title: "People Based ML - Serving Facebook Ads"
author: "Matt Harris"
date: "September 18,2022"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

# Learning Objectives

This lab introduces **classification** as new task in modeling. As opposed to regression where we predict on continuous outcome, classification predicts the probability of one or many events. In this case, we're are only interested in one event; did a user click or not. We will use **Logistic Regression** with the `glm` function to fit this model. Additionally, this lab focuses on finding the correct **threshold** to use for assigning predictions to the classes of click or no-click. Finally, we will use a form of cost optimization to pick the best threshold.

The policy related takeaway from this is that picking a threshold depends on how the predictions will be used in make policy. Much of the time, your job is not to simply make predictions, but to inform stakeholders of how those predictions should be used to implement policy. The lesson of applying a cost optimization method to your predictions is a very important tool in your toolbox.

### Review

-   `dplyr`, `ggplot2` and table joins

-   creating data partitions and `caret`

-   summarizing model objects and cross-validation

### New skills:

-   Using `glm` function and `family="binomial" (link="logit")` to fit a logistic regression models

-   **Goodness-of-fit** metrics with logistic regression models

-   creating a **confusion matrix** and understanding False/True Positives/Negatives

-   Area under the ROC Curve (**AUC**) as a model accuracy metric

-   **Cost-Benefit** optimization with a cost function on your predictions.

# Use Case

Your digital marketing agency is tasked with targeting Facebook users with an ad for a discount fashion brand. To test out a new advertising strategy, you serve an ad to 1000 randomly selected users and see who clicks. You are going to build a model based on their behavior (click or no click) and some attributes about them. We will try to describe and evaluate that model in the context of your business process.


**At various points, there are prompts for you to fill out - those are in bold text. Keep a log of your answers - we will compare notes during or at the end of class.**

 The textbook has a full annotation of the code and describes the details of logistic regression, goodness of fit metrics and more. This workshop mostly just deals with the process and interpretation.

# Set Up

Install libraries and load the data set `advertising`.

These data come from a [Kaggle ML example data set](%22https://www.kaggle.com/faressayah/logistic-regression-tutorial-predict-ad-click?select=advertising.csv%22) and are somewhat edited and contain added noise.

```{r load_packages, warning = FALSE}
options(scipen=10000000)


if(!require(pacman)){install.packages("pacman"); library(pacman)}
p_load(tidyverse, kableExtra, caret, knitr, pscl, plotROC, pROC, lubridate, sf, tidycensus, RSocrata, viridis, spatstat, raster, spdep, FNN, grid, gridExtra, classInt)

root.dir = "https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/DATA/"
source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")

```

```{r load_data, cache = TRUE}
palette5 <- c("#981FAC","#CB0F8B","#FF006A","#FE4C35","#FE9900")
palette4 <- c("#981FAC","#FF006A","#FE4C35","#FE9900")
palette2 <- c("#981FAC","#FF006A")

policeDistricts <- 
  st_read("https://data.cityofchicago.org/api/geospatial/fthy-xz3r?method=export&format=GeoJSON") %>%
  st_transform('ESRI:102271') %>%  
  dplyr::select(District = dist_num)  

# Read and process police beats data
policeBeats <- 
  st_read("https://data.cityofchicago.org/api/geospatial/aerh-rz74?method=export&format=GeoJSON") %>%
  st_transform('ESRI:102271') %>%  
  dplyr::select(District = beat_num)  

# Combine police districts and beats data into one dataframe
bothPoliceUnits <- rbind(
  mutate(policeDistricts, Legend = "Police Districts"), 
  mutate(policeBeats, Legend = "Police Beats")  
)

#Read and process deceptive practice data
deceptivePractice <- 
  read.socrata("https://data.cityofchicago.org/Public-Safety/Crimes-2017/d62x-nvdr") %>% 
  filter(Primary.Type == "DECEPTIVE PRACTICE") %>%  
  mutate(x = gsub("[()]", "", Location)) %>%  
  separate(x, into = c("Y", "X"), sep = ",") %>%  
  mutate(X = as.numeric(X), Y = as.numeric(Y)) %>%  
  na.omit() %>%  
  st_as_sf(coords = c("X", "Y"), crs = 4326, agr = "constant") %>%  
  st_transform('ESRI:102271') %>% 
  distinct()  

# Read and process Chicago boundary data
chicagoBoundary <- 
  st_read(file.path(root.dir, "/Chapter5/chicagoBoundary.geojson")) %>%  
  st_transform('ESRI:102271') 


rDivism <-
  read_csv("https://data.ojp.usdoj.gov/resource/ynf5-u8nk.csv")

```

# Data Exploration

Use the `glimpse` command to check out your data set.

Make some plots of our variables - both continuous and categorical. Examine these plots and then jot down your observations to discussion prompt 1.

## Discussion 1:

**What are some of the average characteristics of people who click on this ad?**

**What are some of the ways in which clickers and non-clickers are different?**

```{r exploratory_continuous}
rDivism %>%
  dplyr::select(gender,gang_affiliated, age_at_release, education_level, prison_offense, prison_years, recidivism_within_3years) %>%
  gather(Variable, value, -recidivism_within_3years) %>%
    ggplot(aes(recidivism_within_3years, value, fill=recidivism_within_3years)) + 
      geom_bar(position = "dodge", stat = "summary", fun = "mean") + 
      facet_wrap(~Variable, scales = "free") +
      scale_fill_manual(values = palette2) +
      labs(x="Recidivism", y="Value", 
           title = "Feature associations with the likelihood of recidivism",
           subtitle = "(continous outcomes)") +
      theme(legend.position = "none")
```

```{r exploratory_continuous_density, message = FALSE, warning = FALSE}
rDivism %>%
    dplyr::select(gender,gang_affiliated, age_at_release, education_level, prison_offense, prison_years, recidivism_within_3years) %>%
    gather(Variable, value, -recidivism_within_3years) %>%
    ggplot() + 
    geom_density(aes(value, color=recidivism_within_3years), fill = "transparent") + 
    facet_wrap(~Variable, scales = "free") +
    scale_fill_manual(values = palette2) +
    labs(title = "Feature distributions recidivism vs. no recidivism",
         subtitle = "(continous outcomes)")
```

```{r exploratory_binary, message = FALSE, warning = FALSE}
rDivism %>%
    dplyr::select(gender, prison_offense, prison_years, recidivism_within_3years) %>%
    gather(Variable, value, -recidivism_within_3years) %>%
    count(Variable, value, recidivism_within_3years) %>%
      ggplot(., aes(value, n, fill = recidivism_within_3years)) +   
        geom_bar(position = "dodge", stat="identity") +
        facet_wrap(~Variable, scales="free") +
        scale_fill_manual(values = palette2) +
        labs(x="Click", y="Value",
             title = "Feature associations with the likelihood of recidivism",
             subtitle = "Categorical features") +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

# Variable Transformations

We have tons of countries in our data set. Most have only a handful of observations. I create a "click average" for each country to use a continuous instead of categorical variable.

  - we haveee many different prison offenses so we can create a click average for each prison offense to use a continuous instead of a categorical variable

I also create a `userTimeFrame` variable to see if the time of day the user is viewing the ad has some kind of effect. 

  - translate this to creating a 'ageTimeFrame' to see if the age of release had an effect on the recidivism rate 

```{r country_variables, cache = TRUE}

rDivism <- 
  rDivism %>% 
  group_by(prison_offense) %>% 
  summarize(totRD = sum(recidivism_within_3years), #except this is not a numeric thing its a binary thing 
            n = n(), 
            nationalrDivism = 100*(totRD/n)) %>%
  dplyr::select(-n, -totRD) %>%
  right_join(rDivism, .) %>%
    mutate(ageTimeFrame = case_when(age_at_release <= 32 ~ "Young",
                                  age_at_release > 33 & age_at_release <= 42 ~ "Middle Aged", 
                                  age_at_release > 43 & age_at_release <= 48 ~ "Old",
                                  age_at_release > 48 ~ "Very Old"))

rDivism <- rDivism %>%
  mutate(prior_arrest_episodes_misd = as.factor(ifelse(prior_arrest_episodes_misd == "6 or more", "6", prior_arrest_episodes_misd)),
         prior_arrest_episodes_felony = as.factor(ifelse(prior_arrest_episodes_felony == "10 or more", "10", prior_arrest_episodes_felony)))
```

# Create A Logistic Regression Model

A logistic regression model predicts a binary outcome - a `1` or a `0` - a `Click` or a `No Click` and associates a coefficient that describes the change in the probability of the outcome given some change in the independent variable. As I mentioned earlier, for a more detailed discussion of logistic regression, consult the text book. - translate this to binary outcomes of recidivism within three years, 1 or 0 where 1 is yes they've commited another crime and 0 is no they have not commited another crime

We partition our data into a 50/50 training and test set (`p = 1.50`). We call these sets `advertisingTrain` and `advertisingTest`.

```{r create_partition}
set.seed(3456)

rDivism$rDivismNumeric <-
  ifelse(rDivism$recidivism_within_3years == "TRUE", 1,0)

trainIndex <- createDataPartition(rDivism$recidivism_within_3years, p = 0.50, #splitting into 50-50 in training and testing models
                                  list = FALSE,
                                  times = 1)
rDivismTrain <- rDivism[ trainIndex,]
rDivismTest  <- rDivism[-trainIndex,]


```

We run our model with the dependent variable `clickNumeric` and we use most of our variables in the regression. (See `dplyr::select`).

```{r run_model}
#not working and idk why - confused about the glm part
rDivismModel <- glm(rDivismNumeric ~ ., #glm is generalized linear model, taking in the defaults
                    data=rDivismTrain %>% 
                    dplyr::select(-prison_offense, -gender, -recidivism_within_3years),
                  family="binomial"(link="logit"))
# i added gender into the model instead of agetime - if we want a more temporal variable
# we can add it too
summary(rDivismModel)
```

## Discussion 3

Observe the output of the first model, and **using the code chunk below play around with the variables you decide to include and exclude. Run the model, and then the subsequent line of code which produces goodness of fit metrics.** How is your McFadden R-squared? It's kind of a pseudo-R-squared, not quite interpretable like R-squared for `lm` models. But the closer to 1, generally the better.

```{r second_model}
rDivismModel2 <- glm(rDivismNumeric ~ .,
                  data=rDivismTrain %>% dplyr::select(-prison_offense, -prison_years, -gender, -race, -education_level),
                  family="binomial" (link="logit"))

summary(rDivismModel2)

```

```{r fit_metrics}

pR2(rDivismModel2) #McFadden is pseudo R squared

```

# Make Predictions


```{r testProbs}
if(class(rDivismTest$prior_arrest_episodes_felony) == "character") {rDivismTest$prior_arrest_episodes_felony <- as.numeric(rDivismTest$prior_arrest_episodes_felony)}

rDivismTest$prior_arrest_episodes_felony[is.na(rDivismTest$prior_arrest_episodes_felony)] <- 10

testProbs <- data.frame(class = rDivismTest$recidivism_within_3years,
                        Outcome = as.factor(rDivismTest$rDivismNumeric),
                        Probs = predict(rDivismModel, rDivismTest, type= "response"))

```

## Discussion 3

```{r plot_testProbs}
ggplot(testProbs, aes(x = Probs, fill = as.factor(Outcome))) + 
  geom_density() +
  facet_grid(Outcome ~ .) +
  scale_fill_manual(values = palette2) +
  labs(x = "Click", y = "Density of probabilities",
       title = "Distribution of predicted probabilities by observed outcome") +
  theme(strip.text.x = element_text(size = 18),
        legend.position = "none")
```

# Confusion Matrix

```{r thresholds}
testProbs <- 
  testProbs %>%
  mutate(predOutcome  = as.factor(ifelse(testProbs$Probs > 0.5 , 1, 0))) #setting threshold of 50%
```

```{r confusion_matrix}
caret::confusionMatrix(testProbs$predOutcome, testProbs$Outcome, 
                       positive = "1") #sensitivity tells us how good at predicting the 1, i.e. true positives. specificity is how good are we at predicting the 0, i.e. true negatives.

```

## Discussion 4


# ROC Curve

```{r auc, message = FALSE, warning = FALSE}
auc(testProbs$Outcome, testProbs$Probs)
```

```{r roc_curve, warning = FALSE, message = FALSE}
ggplot(testProbs, aes(d = as.numeric(Outcome), m = Probs)) +
  geom_roc(n.cuts = 50, labels = FALSE, colour = "#FE9900") +
  style_roc(theme = theme_grey) +
  geom_abline(slope = 1, intercept = 0, size = 1.5, color = 'grey') +
  labs(title = "ROC Curve - clickModel")
```

## Discussion 5

# Cross validation

```{r cv}
ctrl <- trainControl(method = "cv", number = 100, classProbs=TRUE, summaryFunction=twoClassSummary)

cvFit <- train(click ~ .,
                  data=rDivism %>% 
                    dplyr::select(-prison_offense, -prison_years, -gender, -race, -education_level), 
                method="glm", family="binomial",
                metric="ROC", trControl = ctrl)

cvFit
```

```{r goodness_metrics, message = FALSE, warning = FALSE}
dplyr::select(cvFit$resample, -Resample) %>%
  gather(metric, value) %>%
  left_join(gather(cvFit$results[2:4], metric, mean)) %>%
  ggplot(aes(value)) + 
    geom_histogram(bins=35, fill = "#FF006A") +
    facet_wrap(~metric) +
    geom_vline(aes(xintercept = mean), colour = "#981FAC", linetype = 3, size = 1.5) +
    scale_x_continuous(limits = c(0, 1)) +
    labs(x="Goodness of Fit", y="Count", title="CV Goodness of Fit Metrics",
         subtitle = "Across-fold mean reprented as dotted lines")

```

# Cost-Benefit Calculation

## Discussion 6


```{r cost_benefit}
cost_benefit_table <-
   testProbs %>%
      count(predOutcome, Outcome) %>%
      summarize(True_Negative = sum(n[predOutcome==0 & Outcome==0]),
                True_Positive = sum(n[predOutcome==1 & Outcome==1]),
                False_Negative = sum(n[predOutcome==0 & Outcome==1]),
                False_Positive = sum(n[predOutcome==1 & Outcome==0])) %>%
       gather(Variable, Count) %>%
       mutate(Revenue =
               ifelse(Variable == "True_Negative", Count * 0,
               ifelse(Variable == "True_Positive",((.35 - .1) * Count),
               ifelse(Variable == "False_Negative", (-0.35) * Count,
               ifelse(Variable == "False_Positive", (-0.1) * Count, 0))))) %>%
    bind_cols(data.frame(Description = c(
              "We correctly predicted no click",
              "We correctly predicted a click",
              "We predicted no click and customer clicked",
              "We predicted a click and customer did not click")))

kable(cost_benefit_table,
       caption = "Cost/Benefit Table") %>% kable_styling()
```

# Optimize Thresholds

## Discussion 7

```{r iterate_threshold}
iterateThresholds <- function(data) {
  x = .01
  all_prediction <- data.frame()
  while (x <= 1) {
  
  this_prediction <-
      testProbs %>%
      mutate(predOutcome = ifelse(Probs > x, 1, 0)) %>%
      count(predOutcome, Outcome) %>%
      summarize(True_Negative = sum(n[predOutcome==0 & Outcome==0]),
                True_Positive = sum(n[predOutcome==1 & Outcome==1]),
                False_Negative = sum(n[predOutcome==0 & Outcome==1]),
                False_Positive = sum(n[predOutcome==1 & Outcome==0])) %>%
     gather(Variable, Count) %>%
     mutate(Revenue =
               ifelse(Variable == "True_Negative", Count * 0,
               ifelse(Variable == "True_Positive",((.35 - .1) * Count),
               ifelse(Variable == "False_Negative", (-0.35) * Count,
               ifelse(Variable == "False_Positive", (-0.1) * Count, 0)))),
            Threshold = x)
  
  all_prediction <- rbind(all_prediction, this_prediction)
  x <- x + .01
  }
return(all_prediction)
}
```

```{r revenue_model}
whichThreshold <- iterateThresholds(testProbs2)

whichThreshold_revenue <- 
whichThreshold %>% 
    group_by(Threshold) %>% 
    summarize(Revenue = sum(Revenue))

  ggplot(whichThreshold_revenue)+
  geom_line(aes(x = Threshold, y = Revenue))+
  geom_vline(xintercept =  pull(arrange(whichThreshold_revenue, -Revenue)[1,1]))+
    labs(title = "Model Revenues By Threshold For Test Sample",
         subtitle = "Vertical Line Denotes Optimal Threshold")

```

## Post-Script - Interpreting Logit Coefficients

**Explaining the values of the coefficients:**

